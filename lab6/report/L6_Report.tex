\documentclass[aps,letterpaper,11pt]{revtex4}
\input kvmacros
\input{cmacros}

\linespread{1.2}

\usepackage{proof}
\usepackage{graphicx}
\usepackage{float}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{subfig}
\usepackage[usenames,dvipsnames]{color}
\usepackage[pdftex]{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}
\definecolor{gray}{gray}{.96}
\newcommand{\labtitle}{Lab 6 - Polymorphism}
\newcommand{\authorname}{Kevin Burg - John Cole}

\begin{document}

\begin{titlepage}
\begin{center}
{\Large \textsc{\labtitle} \\ \vspace{4pt}} 
\rule[13pt]{\textwidth}{1pt} \\ \vspace{150pt}
{\large By: \authorname \\ \vspace{10pt}
\today}
\end{center}
\end{titlepage}


\section{Introduction}
There are two principle forms of polymorphism: \emph{ad hoc polymorphism} and \emph{parametric polymorphism}.
L5 supports ad hoc polymorphism with its equality \texttt{==} and inequality \texttt{!=} operators. The goal
of our lab is to extend L5 to support parametric polymorphism. We do this by adding language features that
allow for polymorphic datatype definitions and for defining functions which behave uniformly across various
types.

Consider the following program L6 program.

\lstset{language=C, tabsize=3, backgroundcolor=\color{gray}, basicstyle=\small, frame=single,
		commentstyle=\color{BrickRed}, numbers=left}
\lstinputlisting{PolyExample.c}

We say the type \texttt{struct foo} is parameterized by the type \texttt{a}. This is useful because we can 
reuse the struct definition and the \texttt{getSize} function throughout the program on various types.
At line 12, we see an example of instantiating a value of type \texttt{struct foo} where the type
\texttt{int} is substituted for the type parameter \texttt{a}. We enforce that only small types may be
substituted for these type parameters.


\newpage
\section{Specification}

We extend the grammar of L4 in the following way.\\

\begin{tabular}{lll}
$\langle\text{identopt}\rangle$ \hspace{.5in}	& $::=$ & $\epsilon~|~\langle\text{ident}\rangle$\\
$\langle\text{sdecl}\rangle$	& $::=$	& 	\textbf{struct ident} $\langle$identopt$\rangle$\textbf{;}\\
$\langle\text{sdefn}\rangle$	& $::=$	& 	\textbf{struct ident} $\langle$identopt$\rangle$ \textbf{\{}
											$\langle\text{field-list}\rangle$ \textbf{\};}\\
$\langle\text{type}\rangle$	& $::=$	& \ldots $|$ \textbf{$<$}$\langle\text{type}\rangle$\textbf{$>$}
\end{tabular}\\

We need to introduce some notation to explain parameterized structure types. We allow a new form of declaration
$a : \text{type}$ in our context. We write the type of a polymorphic structure in the following way

\begin{center}
$s : \forall a_1, \ldots, a_n. s[a_1, \ldots, a_n]$
\end{center}

In the example from the introduction, we would write $\textbf{struct foo} : \forall a. \textbf{struct foo}[a]$.
Now write the judgement which gives a type to instantiated polymorphic structures is given by
\[
\begin{tabular}{c}
  \infer{\textbf{alloc}(s <\tau_1, \ldots, \tau_n>) : \tau[\tau_1, \dots, \tau_n]^*}
        {	
        	{\tau_1~\text{small}, \ldots, \tau_n~\text{small}} \vspace{.1cm}\\
			{s : \forall a_1, \ldots, a_n. \tau[a_1, \ldots, a_n]}
        }
\end{tabular}
\]
This says two important things. First, it says that any type substitution must occur with a small type.
These are \texttt{int}, \texttt{bool}, etc. Because the small types are all concrete types, and all type
parameters must be provided at allocation, an allocation may never return an object of existential type.

Function types may also be parameterized by type variables. For example, from the introduction,
$$\texttt{getSize} : \forall a. (\textbf{struct foo}[a]) -> \texttt{int}$$

Type checking the use of polymorphic functions requires a definition of type variable substitution. Suppose
$\theta$ is our substitution, then the judgement that allows us to type check the use of polymorphic
functions is given by

\[
\begin{tabular}{c}
  \infer{\Gamma \vdash f(e_1, \ldots, e_n) : \theta(\tau)}
        {	
        	{f : \forall a_1, \ldots, a_k. (\tau_1, \ldots, \tau_n) \rightarrow \tau}\\
			{\Gamma \vdash \theta : (a_1, \ldots, a_k)}\\
			{\Gamma \vdash e_1 : \theta(\tau_1), \ldots, e_n : \theta(\tau_n)}
        }
\end{tabular}
\]

The only way that a function may be parameterized by type variables, is if the type variables occur free in
struct types. We have not yet implemented the functionality that would allow us to write a function that
has the following type
$$\texttt{foo} : \forall a. (a~\textbf{list}) -> \texttt{int}$$

This is something we would implement in the future.

\newpage
\section{Implementation}

First we will describe the execution of our compiler before going into detail about the parts which were changed
in lab 6. the program is parsed into a form we call PST before being elaborated into a form we call AST. 
Elaboration follows a set of rules for translating sequences of statements into a form that makes type checking
more natural. The elaboration phase also takes care of separating all the information in the PST into groups
such as function definitions, type definitions, and structure definitions. The CheckAST module then reads
through this AST structure to check that it is well-formed according to the statics of our language definition.

Upon success, we send the \emph{PST} to the CodeGen module where the rest of translation, register allocation,
and optimization happens. This means that we \emph{throw out} the AST after static checks and return to
the data structure we had before elaboration. Obviously, some information is lost here, burin the earlier labs,
it seemed more natural to generate code from the PST than the AST. Now it means we have to type check
expressions \emph{during} code generation to ensure we do everything correctly. This isn't ideal. If we could 
do it all again, we would sort out this problem with our IR.

Parametric polymorphism itself does not require much change to the code generation part of the compiler. Most
of the changes were to the CheckAST module. One of the changes that needed to be made was determining the types
of struct field accesses when the structs are parameterized by type variables. From the example in introduction,
we needed to determine the type of \texttt{s->array} on line 14. The way we did this was to extend the datatype
which held the type of structs with a field for map of types that may have been substituted in at allocation.
Then, when the access happens, we see that \texttt{s->array} has type \texttt{$a$ list}. By looking into the
map, we see that $a$ was substituted with \texttt{int}, making the actual type \texttt{int list}.

Another problem is checking that function calls to polymorphic functions are correct. Consider the following function definition.\\

\lstset{language=C, tabsize=3, backgroundcolor=\color{gray}, basicstyle=\small, frame=single,
		commentstyle=\color{BrickRed}, numbers=none}
\lstinputlisting{PolyFunction.c}

We would like to only allow calls to this function where the first and second argument have the same substitution
for $a$. To do this, we build up the substitution from left to right, making sure that any additional 
substitutions are consistent with what we already have.


\newpage
\section{Testing Methodology}

\newpage
\section{Analysis}


\end{document}


%%%%%%%%%%%%%%%%
COMMON COMMANDS:
%%%%%%%%%%%%%%%%
% IMAGES
\begin{figure}[H]
   \begin{center}
      \includegraphics[width=0.6\textwidth]{RTL_SCHEM.png}
   \end{center}
\caption{A screenshot of the RTL Schematics produced from the Verilog code.}
\label{RTL}
\end{figure}

% SUBFIGURES IMAGES
\begin{figure}[H]
  \centering
  \subfloat[LED4 Period]{\label{fig:Per4}\includegraphics[width=0.4\textwidth]{period_led4.png}} \\                
  \subfloat[LED5 Period]{\label{fig:Per5}\includegraphics[width=0.4\textwidth]{period_led5.png}}
  \subfloat[LED6 Period]{\label{fig:Per6}\includegraphics[width=0.4\textwidth]{period_led6.png}}
  \caption{Period of LED blink rate captured by osciliscope.}
  \label{fig:oscil}
\end{figure}

% INSERT SOURCE CODE
\lstset{language=Verilog, tabsize=3, backgroundcolor=\color{mygrey}, basicstyle=\small, commentstyle=\color{BrickRed}}
\lstinputlisting{MODULE.v}

% TEXT TABLE
\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|l|}
	x & x & x & x \\ \hline
	x & x & x & x \\
	x & x & x & x \\ \hline
\end{tabular}
\caption{Caption}
\label{label}
\end{center}
\end{table}

% MATHMATICAL ENVIRONMENT
$ 8 = 2 \times 4 $

% CENTERED FORMULA
\[  \]

% NUMBERED EQUATION
\begin{equation}
	
\end{equation}

% ARRAY OF EQUATIONS (The splat supresses the numbering)
\begin{align*}
	
\end{align*}

% NUMBERED ARRAY OF EQUATIONS
\begin{align}
	
\end{align}

% ACCENTS
\dot{x} % dot
\ddot{x} % double dot
\bar{x} % bar
\tilde{x} % tilde
\vec{x} % vector
\hat{x} % hat
\acute{x} % acute
\grave{x} % grave
\breve{x} % breve
\check{x} % dot (cowboy hat)

% FONTS
\mathrm{text} % roman
\mathsf{text} % sans serif
\mathtt{text} % Typewriter
\mathbb{text} % Blackboard bold
\mathcal{text} % Caligraphy
\mathfrak{text} % Fraktur

\textbf{text} % bold
\textit{text} % italic
\textsl{text} % slanted
\textsc{text} % small caps
\texttt{text} % typewriter
\underline{text} % underline
\emph{text} % emphasized

\begin{tiny}text\end{tiny} % Tiny
\begin{scriptsize}text\end{scriptsize} % Script Size
\begin{footnotesize}text\end{footnotesize} % Footnote Size
\begin{small}text\end{small} % Small
\begin{normalsize}text\end{normalsize} % Normal Size
\begin{large}text\end{large} % Large
\begin{Large}text\end{Large} % Larger
\begin{LARGE}text\end{LARGE} % Very Large
\begin{huge}text\end{huge}   % Huge
\begin{Huge}text\end{Huge}   % Very Huge


% GENERATE TABLE OF CONTENTS AND/OR TABLE OF FIGURES
% These seem to have some issues with the "revtex4" document class.  To use, change
% the very first line of this document to "article" like this:
% \documentclass[aps,letterpaper,10pt]{article}
\tableofcontents
\listoffigures
\listoftables

% INCLUDE A HYPERLINK OR URL
\url{http://www.derekhildreth.com}
\href{http://www.derekhildreth.com}{Derek Hildreth's Website}

% FOR MORE, REFER TO THE "LINUX CHEAT SHEET.PDF" FILE INCLUDED!
